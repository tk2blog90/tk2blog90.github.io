{"title":"Angular reusable FileDropzoneDirective","description":"Drag and drop to upload files","keywords":["Angular","JavaScript","TypeScript","Drag and drop","File upload","File dropzone"],"tags":["Angular2+","JavaScript","TypeScript","Drag and Drop"],"banner":"/assets/images/posts/10/banner.png","thumbnail":"/assets/images/posts/10/thumbnail.png","bannerCredit":{"name":"Towfiqu barbhuiya","id":"@towfiqu999999"},"publish":"2022-05-18 20:13:00","id":"10","contents":"We often need to allow users to upload files to their browser.\r\nIn this case, using the traditional HTML file input can be a way.\r\nBut, if user convenience is considered, drag and drop is also possible.\r\nSo, today I'll introduce the Angular `FileDropzoneDirective`.\r\n\r\n# How it Works\r\n\r\nIn order to be able to use it for various forms of dropzone,\r\nI made it as a `Directive` rather than a `Component`.\r\n\r\n`FileDropzoneDirective` is associated with the file input.\r\nSo it receives the file input with `@Input()` decorator and detects the `change` event of the file input.\r\nIt also detects `drop` event that occur on it.\r\n\r\nAfter detecting the `change` and `drop` event,\r\nthe uploaded files are validated and `success` or `error`\r\nemitter is emitted according to validation result.\r\n\r\n# FileDropzoneDirective (Full source code)\r\n\r\n```typescript\r\n/**\r\n * Mime types are consist of `${type}/${sub-type}`.\r\n * This object maps mime types of `accept` field.\r\n */\r\nexport interface MimeTypesMap {\r\n  [type: string]: {\r\n    [subtype: string]: boolean;\r\n  }\r\n}\r\n\r\n/**\r\n * Neutralize the Event.\r\n * @param event Event.\r\n */\r\nfunction neutralize(event: Event): void {\r\n  event.stopPropagation();\r\n  event.preventDefault();\r\n}\r\n\r\n@Directive({\r\n  selector: '[appFileDropzone]'\r\n})\r\nexport class FileDropzoneDirective implements OnDestroy {\r\n  /**\r\n   * Set acceptable file types.\r\n   * Should be an array of mime types.\r\n   */\r\n  @Input() accept: string[] = [\r\n    '*/*',\r\n  ];\r\n\r\n  /**\r\n   * Emit uploaded files as an array.\r\n   */\r\n  @Output() success = new EventEmitter<File[]>();\r\n\r\n  /**\r\n   * Emit error message.\r\n   */\r\n  @Output() error = new EventEmitter<string>();\r\n\r\n  /**\r\n   * Dropzone activated state.\r\n   */\r\n  @HostBinding('class.active') active = false;\r\n\r\n  /**\r\n   * File input element.\r\n   */\r\n  private _input?: HTMLInputElement;\r\n\r\n  constructor() {\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this._removeInputChangeEvent();\r\n  }\r\n\r\n  /**\r\n   * Get state of allowing multiple files.\r\n   */\r\n  get multi(): boolean {\r\n    return this._input?.hasAttribute('multi') || false;\r\n  }\r\n\r\n  /**\r\n   * Map the `accept` field with `type` and `subtype`.\r\n   */\r\n  get mimeTypesMap(): MimeTypesMap {\r\n    const mimeTypesMap: MimeTypesMap = {};\r\n\r\n    this.accept.forEach(mimeType => {\r\n      const [type, subtype] = mimeType.split('/');\r\n\r\n      if (!mimeTypesMap[type]) {\r\n        mimeTypesMap[type] = {};\r\n      }\r\n\r\n      if (!mimeTypesMap[type][subtype]) {\r\n        mimeTypesMap[type][subtype] = true;\r\n      }\r\n    });\r\n\r\n    return mimeTypesMap;\r\n  }\r\n\r\n  /**\r\n   * Set file input element.\r\n   * If the `input` is an instance of `ElementRef`, extract `nativeElement` from it.\r\n   * @param input Input element.\r\n   */\r\n  @Input() set input(input: HTMLInputElement | ElementRef<HTMLInputElement>) {\r\n    this._removeInputChangeEvent();\r\n\r\n    if (input instanceof ElementRef) {\r\n      this._input = input.nativeElement;\r\n    } else {\r\n      this._input = input;\r\n    }\r\n\r\n    this._addInputChangeListener();\r\n  }\r\n\r\n  @HostListener('window:dragover', ['$event'])\r\n  onWindowDragover(event: DragEvent): void {\r\n    neutralize(event);\r\n  }\r\n\r\n  @HostListener('window:drop', ['$event'])\r\n  onWindowDrop(event: DragEvent): void {\r\n    neutralize(event);\r\n  }\r\n\r\n  @HostListener('dragover')\r\n  onHostDragOver(): void {\r\n    this.active = true;\r\n  }\r\n\r\n  @HostListener('dragleave')\r\n  onHostDragLeave(): void {\r\n    this.active = false;\r\n  }\r\n\r\n  @HostListener('dragend')\r\n  onHostDragEnd(): void {\r\n    this.active = false;\r\n  }\r\n\r\n  /**\r\n   * Handle `drop` on this dropzone.\r\n   * @param event DragEvent.\r\n   */\r\n  @HostListener('drop', ['$event'])\r\n  onHostDrop(event: DragEvent): void {\r\n    this.active = false;\r\n\r\n    if (event.dataTransfer?.files) {\r\n      this._handleFiles(event.dataTransfer.files);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add `change` event listener to file input.\r\n   */\r\n  private _addInputChangeListener(): void {\r\n    if (this._input) {\r\n      this._input.addEventListener('change', this._onInputChange);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove `change` event listener from file input.\r\n   */\r\n  private _removeInputChangeEvent(): void {\r\n    if (this._input) {\r\n      this._input.removeEventListener('change', this._onInputChange);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The `change` event listener for file input.\r\n   */\r\n  private _onInputChange = (): void => {\r\n    if (this._input?.files) {\r\n      this._handleFiles(this._input.files);\r\n\r\n      // Remove the value of file input.\r\n      // This is to allow uploading of the same file(s).\r\n      this._input.value = '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle both `host.drop` and `input.change` event.\r\n   * Validate file and emit `success` or `error` emitter based on the validation result.\r\n   * @param files Uploaded FileList.\r\n   */\r\n  private _handleFiles(files: FileList): void {\r\n    try {\r\n      this.success.emit(this._validateFiles(files));\r\n    } catch (e) {\r\n      this.error.emit((e as Error).message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate the file length and types.\r\n   * @param files Uploaded FileList.\r\n   */\r\n  private _validateFiles(files: FileList): File[] {\r\n    const mimeTypesMap = this.mimeTypesMap;\r\n    const validatedFiles: File[] = [];\r\n\r\n    // Check whether multiple files can be uploaded or not.\r\n    if (!this.multi && files.length > 1) {\r\n      throw new Error('Multi Error');\r\n    }\r\n\r\n    for (let i = 0; i < files.length; i++) {\r\n      const file = files.item(i) as File;\r\n\r\n      const [type, subtype] = file.type.split('/');\r\n\r\n      // Check Mimetype.\r\n      // Since the first object can be `undefined`, `{}` is set as the default value of the first object.\r\n      if (\r\n        // If there is `*/*` in the `accept` field, all mimetypes are allowed to upload.\r\n        // Other mimetypes are redundant if `*/*` is set in the `accept` field.\r\n        (mimeTypesMap['*'] || {})['*']\r\n\r\n        // Check `*` wildcard for specific type.\r\n        // If the `accept` field is `['image/*', 'text/*'],\r\n        // all images and texts are allowed to upload.\r\n        || (mimeTypesMap[type] || {})['*']\r\n\r\n        // Check specific type.\r\n        // If the `accept` field is `['image/png', 'text/javascript']`,\r\n        // only png images and javascript files are allowed to upload.\r\n        || (mimeTypesMap[type] || {})[subtype]\r\n      ) {\r\n        validatedFiles.push(file);\r\n      } else {\r\n        throw new Error('Mimetype Error');\r\n      }\r\n    }\r\n\r\n    return validatedFiles;\r\n  }\r\n}\r\n```\r\n\r\n# Code Review\r\n\r\n```typescript\r\n@Directive({\r\n  selector: '[appFileDropzone]'\r\n})\r\nexport class FileDropzoneDirective implements OnDestroy {\r\n  // ...\r\n  \r\n  /**\r\n   * Set file input element.\r\n   * If the `input` is an instance of `ElementRef`, extract `nativeElement` from it.\r\n   * @param input Input element.\r\n   */\r\n  @Input() set input(input: HTMLInputElement | ElementRef<HTMLInputElement>) {\r\n    this._removeInputChangeEvent();\r\n\r\n    if (input instanceof ElementRef) {\r\n      this._input = input.nativeElement;\r\n    } else {\r\n      this._input = input;\r\n    }\r\n\r\n    this._addInputChangeListener();\r\n  }\r\n  \r\n  // ...\r\n}\r\n```\r\n\r\nThe first flow is to set the `HTMLInputElement` using the `input` setter.\r\nBefore `HTMLInputElement` is updated,\r\nthe `_removeInputChangeEvent()` method is called to remove the `change` listener\r\nbound to the existing `HTMLInputElement` if it exists.\r\n\r\nAfter updating the `HTMLInputElement`,\r\nthe `_addInputChangeListener()` method is called to add a `change` listener to the new `HTMLInputElement`.\r\n\r\nIf files are uploaded by `HTMLInputElement`, the `_onInputChange()` method is called.\r\nThis method calls the `_handleFiles()` method which validates the uploaded files \r\nand emits `success` or `error` emitter depending on the result.\r\n\r\n\r\n```typescript\r\n@Directive({\r\n  selector: '[appFileDropzone]'\r\n})\r\nexport class FileDropzoneDirective implements OnDestroy {\r\n  // ...\r\n  \r\n  /**\r\n   * Validate the file length and types.\r\n   * @param files Uploaded FileList.\r\n   */\r\n  private _validateFiles(files: FileList): File[] {\r\n    const mimeTypesMap = this.mimeTypesMap;\r\n    const validatedFiles: File[] = [];\r\n\r\n    // Check whether multiple files can be uploaded or not.\r\n    if (!this.multi && files.length > 1) {\r\n      throw new Error('Multi Error');\r\n    }\r\n\r\n    for (let i = 0; i < files.length; i++) {\r\n      const file = files.item(i) as File;\r\n\r\n      const [type, subtype] = file.type.split('/');\r\n\r\n      // Check Mimetype.\r\n      // Since the first object can be `undefined`, `{}` is set as the default value of the first object.\r\n      if (\r\n        // If there is `*/*` in the `accept` field, all mimetypes are allowed to upload.\r\n        // Other mimetypes are redundant if `*/*` is set in the `accept` field.\r\n        (mimeTypesMap['*'] || {})['*']\r\n\r\n        // Check `*` wildcard for specific type.\r\n        // If the `accept` field is `['image/*', 'text/*'],\r\n        // all images and texts are allowed to upload.\r\n        || (mimeTypesMap[type] || {})['*']\r\n\r\n        // Check specific type.\r\n        // If the `accept` field is `['image/png', 'text/javascript']`,\r\n        // only png images and javascript files are allowed to upload.\r\n        || (mimeTypesMap[type] || {})[subtype]\r\n      ) {\r\n        validatedFiles.push(file);\r\n      } else {\r\n        throw new Error('Mimetype Error');\r\n      }\r\n    }\r\n\r\n    return validatedFiles;\r\n  }\r\n}\r\n```\r\n\r\nFile validating is done by the `_validateFiles()` method.\r\nIt first validates the number of uploaded files according to whether the `HTMLInputElement` allows multiple files.\r\n\r\nIf the file count validation passes, the next step is to validate the mimetype of each file.\r\nThe `accept` field is used here.\r\n\r\nThe `accept` field is an array of allowed mimetypes.\r\nThe default value is `['*/*']`, which means that all file types are allowed.\r\nIf the value of the `accept` field is `['image/*', 'text/javascript']`,\r\nthen all image files will be accepted and only text files in JavaScript type will be accepted.\r\n\r\nFiles that have passed mimetype validation are returned as the result of the method.\r\n\r\n```typescript\r\n@Directive({\r\n  selector: '[appFileDropzone]'\r\n})\r\nexport class FileDropzoneDirective implements OnDestroy {\r\n  // ...\r\n  \r\n  /**\r\n   * Handle `drop` on this dropzone.\r\n   * @param event DragEvent.\r\n   */\r\n  @HostListener('drop', ['$event'])\r\n  onHostDrop(event: DragEvent): void {\r\n    this.active = false;\r\n\r\n    if (event.dataTransfer?.files) {\r\n      this._handleFiles(event.dataTransfer.files);\r\n    }\r\n  }\r\n  \r\n  // ...\r\n\r\n  /**\r\n   * The `change` event listener for file input.\r\n   */\r\n  private _onInputChange = (): void => {\r\n    if (this._input?.files) {\r\n      this._handleFiles(this._input.files);\r\n\r\n      // Remove the value of file input.\r\n      // This is to allow uploading of the same file(s).\r\n      this._input.value = '';\r\n    }\r\n  }\r\n  \r\n  // ...\r\n}\r\n```\r\n\r\nThe key methods to detect the `change` event of `HTMLInputElement`\r\nand the `drop` event of dropzone are `_onInputChange()` and `onHostDrop()`.\r\n\r\nBoth methods eventually go through the process of validation and emitting by calling the `_handleFiles()` method.\r\n\r\n```typescript\r\n@Directive({\r\n  selector: '[appFileDropzone]'\r\n})\r\nexport class FileDropzoneDirective implements OnDestroy {\r\n  // ...\r\n\r\n  @HostListener('window:dragover', ['$event'])\r\n  onWindowDragover(event: DragEvent): void {\r\n    neutralize(event);\r\n  }\r\n\r\n  @HostListener('window:drop', ['$event'])\r\n  onWindowDrop(event: DragEvent): void {\r\n    neutralize(event);\r\n  }\r\n  \r\n  // ...\r\n}\r\n```\r\n\r\nThis is the part you must remember to create a dropzone.\r\nI have neutralized the `dragover` and `drop` events of `window`.\r\nWithout this part, dropzone will not work properly.\r\n\r\n# Usage\r\n\r\n```html\r\n<div\r\n  (error)=\"onError($event)\"\r\n  (success)=\"onSuccess($event)\"\r\n  [accept]=\"['image/*']\"\r\n  [input]=\"input\"\r\n  appFileDropzone\r\n  class=\"dropzone\"></div>\r\n\r\n<input\r\n  #input\r\n  type=\"file\"/>\r\n```\r\n\r\n```scss\r\n.dropzone {\r\n  width: 300px;\r\n  height: 300px;\r\n  border: 1px dashed #ccc;\r\n\r\n  &.active {\r\n    border: 1px solid #6F86C5;\r\n    outline: 1px solid #6F86C5;\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: ['./app.component.scss']\r\n})\r\nexport class AppComponent {\r\n  onSuccess(files: File[]): void {\r\n    console.log('Uploaded:', files);\r\n  }\r\n\r\n  onError(error: string): void {\r\n    console.log('Error:', error);\r\n  }\r\n}\r\n```\r\n","created":"2022-05-18 20:13:00"}