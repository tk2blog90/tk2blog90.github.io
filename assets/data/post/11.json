{"title":"Create Angular custom form controls with ControlValueAccessor","description":"Usage of ControlValueAccessor","keywords":["Angular","JavaScript","TypeScript","FormControl","ControlValueAccessor"],"tags":["Angular2+","JavaScript","TypeScript","FormControl"],"banner":"/assets/images/posts/11/banner.png","thumbnail":"/assets/images/posts/11/thumbnail.png","bannerCredit":{"name":"Markus Spiske","id":"@markusspiske"},"publish":"2022-05-23 17:23:00","id":"11","contents":"Angular is a great framework that supports two-way binding.\r\nYou can set the `value` using the `@Input` decorator and\r\ntransmit the changed value to the parent component\r\nby emitting the `valueChange` emitter using the `@Output` decorator.\r\n\r\nThis is useful when creating simple form fields.\r\nHowever, this method has limitations.\r\n\r\nFirst, the components like above cannot be included in `FormGroup`.\r\nThis is because `FormGroup` class of Angular allows `FormControl` elements to be managed as a group,\r\nbut `FormControl` cannot be bound to those components.\r\n\r\nSecond, you cannot use Validator because `FormControl` cannot be bound.\r\nWhen the value of `FormControl` is changed, Validator validates the value and sets the error status to `FormControl`.\r\n\r\nThis makes it difficult for you to manage components.\r\n\r\nTo solve this problem, you can create your own form controls using `ControlValueAccessor`.\r\n\r\n# ControlValueAccessor\r\n\r\n`ControlValueAccessor` is the key to creating custom form controls.\r\nYou can implement this in your component to allow binding of `ngModel` and `FormControl`.\r\n\r\n```typescript\r\n/**\r\n * @description\r\n * Defines an interface that acts as a bridge between the Angular forms API and a\r\n * native element in the DOM.\r\n *\r\n * Implement this interface to create a custom form control directive\r\n * that integrates with Angular forms.\r\n *\r\n * @see DefaultValueAccessor\r\n *\r\n * @publicApi\r\n */\r\nexport declare interface ControlValueAccessor {\r\n    /**\r\n     * @description\r\n     * Writes a new value to the element.\r\n     *\r\n     * This method is called by the forms API to write to the view when programmatic\r\n     * changes from model to view are requested.\r\n     *\r\n     * @usageNotes\r\n     * ### Write a value to the element\r\n     *\r\n     * The following example writes a value to the native DOM element.\r\n     *\r\n     * ```ts\r\n     * writeValue(value: any): void {\r\n     *   this._renderer.setProperty(this._elementRef.nativeElement, 'value', value);\r\n     * }\r\n     * ```\r\n     *\r\n     * @param obj The new value for the element\r\n     */\r\n    writeValue(obj: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a callback function that is called when the control's value\r\n     * changes in the UI.\r\n     *\r\n     * This method is called by the forms API on initialization to update the form\r\n     * model when values propagate from the view to the model.\r\n     *\r\n     * When implementing the `registerOnChange` method in your own value accessor,\r\n     * save the given function so your class calls it at the appropriate time.\r\n     *\r\n     * @usageNotes\r\n     * ### Store the change function\r\n     *\r\n     * The following example stores the provided function as an internal method.\r\n     *\r\n     * ```ts\r\n     * registerOnChange(fn: (_: any) => void): void {\r\n     *   this._onChange = fn;\r\n     * }\r\n     * ```\r\n     *\r\n     * When the value changes in the UI, call the registered\r\n     * function to allow the forms API to update itself:\r\n     *\r\n     * ```ts\r\n     * host: {\r\n     *    '(change)': '_onChange($event.target.value)'\r\n     * }\r\n     * ```\r\n     *\r\n     * @param fn The callback function to register\r\n     */\r\n    registerOnChange(fn: any): void;\r\n    /**\r\n     * @description\r\n     * Registers a callback function that is called by the forms API on initialization\r\n     * to update the form model on blur.\r\n     *\r\n     * When implementing `registerOnTouched` in your own value accessor, save the given\r\n     * function so your class calls it when the control should be considered\r\n     * blurred or \"touched\".\r\n     *\r\n     * @usageNotes\r\n     * ### Store the callback function\r\n     *\r\n     * The following example stores the provided function as an internal method.\r\n     *\r\n     * ```ts\r\n     * registerOnTouched(fn: any): void {\r\n     *   this._onTouched = fn;\r\n     * }\r\n     * ```\r\n     *\r\n     * On blur (or equivalent), your class should call the registered function to allow\r\n     * the forms API to update itself:\r\n     *\r\n     * ```ts\r\n     * host: {\r\n     *    '(blur)': '_onTouched()'\r\n     * }\r\n     * ```\r\n     *\r\n     * @param fn The callback function to register\r\n     */\r\n    registerOnTouched(fn: any): void;\r\n    /**\r\n     * @description\r\n     * Function that is called by the forms API when the control status changes to\r\n     * or from 'DISABLED'. Depending on the status, it enables or disables the\r\n     * appropriate DOM element.\r\n     *\r\n     * @usageNotes\r\n     * The following is an example of writing the disabled property to a native DOM element:\r\n     *\r\n     * ```ts\r\n     * setDisabledState(isDisabled: boolean): void {\r\n     *   this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\r\n     * }\r\n     * ```\r\n     *\r\n     * @param isDisabled The disabled status to set on the element\r\n     */\r\n    setDisabledState?(isDisabled: boolean): void;\r\n}\r\n```\r\n\r\nYou can see 4 methods in the above interface.\r\n\r\n## writeValue()\r\n\r\nThe `writeValue()` method needs to set the value which is set in `ngModel` or `FormControl` to the component.\r\n\r\nThis must be implemented.\r\n\r\n## registerOnChange()\r\n\r\nThe `registerOnChange()` method needs to register a change listener of `ngModel` or `FormControl` in your component.\r\nWhen you call this change listener with `value`, `ngModelChange` or `FormControl.valueChanges` is triggered.\r\n\r\nThis must be implemented.\r\n\r\n## registerOnTouched()\r\n\r\nThe `registerOnTouched()` method registers the touched listener of `ngModel` or `FormControl` in your component.\r\nWhen the touched listener is called, the state of your component changes from `untouched` to `touched`.\r\n\r\nThis must be implemented.\r\n\r\n## setDisabledState()\r\n\r\nThe `setDisabledState()` method needs to reflect the state of disabled to your component\r\nwhen `ngModel` or `FormControl` is disabled or enabled.\r\n\r\nThis is optional method.\r\n\r\n# CustomFormControl\r\n\r\nYou can create your own `FormControl` simply by implementing `ControlValueAccessor`.\r\nRead more about this from here:\r\n[Angular Custom Form Controls: Complete Guide](https://blog.angular-university.io/angular-custom-form-controls/).\r\n\r\nHowever, I would make it an extensible Angular Directive class for general purpose.\r\nThe reason for implementing Angular Directive is to use Angular's Dependency Injection.\r\n\r\n```typescript\r\nimport {Directive, HostBinding, Input, Optional, Self} from '@angular/core';\r\nimport {ControlValueAccessor, NgControl} from '@angular/forms';\r\nimport {environment} from '../../../../environments/environment';\r\n\r\nconst {\r\n  production,\r\n} = environment;\r\n\r\n/**\r\n * The base class to create customized `FormControl`.\r\n */\r\n@Directive({\r\n  selector: '[appCustomFormControl]'\r\n})\r\nexport class CustomFormControl<T> implements ControlValueAccessor {\r\n  /**\r\n   * Set component tabindex.\r\n   */\r\n  @Input() @HostBinding('attr.tabindex') tabindex = 0;\r\n\r\n  /**\r\n   * `OnChange` callback function.\r\n   */\r\n  protected _onChange: any;\r\n\r\n  /**\r\n   * `OnTouched` callback function.\r\n   */\r\n  protected _onTouched: any;\r\n\r\n  constructor(\r\n    @Self() @Optional() public ngControl: NgControl,\r\n  ) {\r\n    if (ngControl) {\r\n      ngControl.valueAccessor = this;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Should be implemented by extended class.\r\n   * @param value - The value.\r\n   */\r\n  writeValue(value: T): void {\r\n    // Show warning when `writeValue()` method is not overwritten.\r\n    if (!production) {\r\n      console.warn(`'writeValue()' method is not implemented.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set value to `NgControl`.\r\n   * @param value - The value.\r\n   */\r\n  setValue(value: T): void {\r\n    // When setting value to `NgControl`,\r\n    // write changed value to the Component/Directive by calling `writeValue()` method as well.\r\n    this.writeValue(value);\r\n    this.markAsDirty(value);\r\n  }\r\n\r\n  /**\r\n   * Should be implemented by extended class.\r\n   * @param isDisabled - The disabled state.\r\n   */\r\n  setDisabledState(isDisabled: boolean): void {\r\n    // Show warning when `setDisabledState()` method is not overwritten.\r\n    if (!production) {\r\n      console.warn(`'setDisabledState()' method is not implemented.`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call `OnChange` callback function.\r\n   * @param value - The value.\r\n   */\r\n  markAsDirty(value: T): void {\r\n    if (this._onChange) {\r\n      this._onChange(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call `OnTouched` callback function.\r\n   */\r\n  markAsTouched(): void {\r\n    if (this._onTouched) {\r\n      this._onTouched();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Register `OnChange` callback function to class.\r\n   * @param fn - The function of `OnChange`.\r\n   */\r\n  registerOnChange(fn: any): void {\r\n    this._onChange = fn;\r\n  }\r\n\r\n  /**\r\n   * Register `OnTouched` callback function to class.\r\n   * @param fn - The function of `OnTouched`.\r\n   */\r\n  registerOnTouched(fn: any): void {\r\n    this._onTouched = fn;\r\n  }\r\n}\r\n\r\n```\r\n\r\nIf you've read the article linked above,\r\nyou'll notice that there is no `NG_VALUE_ACCESSOR` provider in my code.\r\n\r\nI used the `@Self()` decorator to detect the `NgControl` injected into this class,\r\nand set the `valueAccessor` of the `NgControl` as this class.\r\n\r\nSo the injected `NgControl` will use\r\n`writeValue()`, `registerOnChange()`, `registerOnTouched()`, and `setDisabledState()` of this class.\r\n\r\nAnd I also used the `@Optional()` decorator, because `NgControl` may not have been injected.\r\n\r\nThe part you should pay attention to in the code above is the `setValue()` method.\r\nThe `setValue()` method calls the `writeValue()` method to write the value back to the component.\r\nIf this part is not present, you have to manually update the component value before updating the value.\r\n\r\n# Usage\r\n\r\nNow let's create an `CheckboxComponent` using `CustomFormControl`.\r\n\r\n```typescript\r\n@Component({\r\n  selector: 'app-checkbox',\r\n  templateUrl: './checkbox.component.html',\r\n  styleUrls: ['./checkbox.component.scss']\r\n})\r\nexport class CheckboxComponent extends CustomFormControl<boolean> {\r\n  /**\r\n   * Disabled state.\r\n   */\r\n  @HostBinding('class.disabled') disabled = false;\r\n  \r\n  /**\r\n   * Set component tabindex.\r\n   */\r\n  @Input() @HostBinding('attr.tabindex') tabindex = 0;\r\n\r\n  /**\r\n   * Checked state.\r\n   */\r\n  checked = false;\r\n\r\n  constructor(\r\n    @Self() @Optional() public override ngControl: NgControl,\r\n  ) {\r\n    super(ngControl);\r\n  }\r\n\r\n  /**\r\n   * Write checked state.\r\n   * @param value - The value.\r\n   */\r\n  override writeValue(value: boolean): void {\r\n    this.checked = value;\r\n  }\r\n\r\n  /**\r\n   * Set checkbox disabled.\r\n   * @param isDisabled - Disabled state.\r\n   */\r\n  override setDisabledState(isDisabled: boolean): void {\r\n    this.disabled = isDisabled;\r\n  }\r\n\r\n  /**\r\n   * Listen host `click` event to toggle checked state.\r\n   */\r\n  @HostListener('click')\r\n  onHostClick(): void {\r\n    this.setValue(!this.checked);\r\n  }\r\n\r\n  /**\r\n   * Listen host `blur` event to mark as touched.\r\n   */\r\n  @HostListener('blur')\r\n  onHostBlur(): void {\r\n    this.markAsTouched();\r\n  }\r\n}\r\n```\r\n\r\nThe generic of `CustomFormControl` indicates the type of the value of `FormControl`.\r\nA checkbox has a checked/unchecked state, so use a `boolean` type.\r\n\r\nThis overrides the `writeValue()` method to change the value of the `checked` property.\r\nWhen the host element is clicked, the `checked` state is changed by calling the `setValue()` method.\r\nAnd, when a blur event occurs from the host element,\r\nthe `markAsTouched()` method is called to change the status of `NgControl` to `touched`.\r\n\r\nYou can show/hide check icon in html template according to `checked` value.\r\n\r\nNow you can use `CheckboxComponent` like below.\r\n\r\n```html\r\n<!-- Bind with `ngModel`. -->\r\n<app-checkbox [(ngModel)]=\"checked\"></app-checkbox>\r\n```\r\n\r\n```html\r\n<!-- Use `FormControl`. -->\r\n<app-checkbox [formControl]=\"control\"></app-checkbox>\r\n```\r\n\r\n```html\r\n<!-- Use `formControlName` with `FormGroup`. -->\r\n<form [formGroup]=\"group\">\r\n  <app-checkbox formControlName=\"checkbox\"></app-checkbox>\r\n</form>\r\n```\r\n\r\n# Conclusion\r\n\r\nLike `CheckboxComponent`, you can create your own `FormControl` using `CustomFormControl` if needed.\r\nI hope this article was helpful.\r\nEnjoy Angular development!\r\n","created":"2022-05-23 17:23:00"}