---
layout: post
title: Cannot inject Renderer2 when the application uses Renderer3! 해결법
description: Angular 13.2.0 버그
subject: Dev
keywords: Angular, Bug, 버그, Renderer3, Renderer2
---

이번 포스팅은 최근에 Angular 13.1.1에서 13.2.0으로 업데이트를 하며 발견된 버그에 관한 것이다.

# Dynamic component rendering

Angular에서는 템플릿에 포함되어있지 않은 컴포넌트를 동적으로 추가할 수 있다.
자세한 내용은 [Angular 공식 문서](https://angular.io/guide/dynamic-component-loader)를 참고하자.

여기서 간단하게 설명하자면 Angular의 `ViewContainerRef` 클래스는 `createComponent()`라는 메서드를 지원한다.
이 메서드에 버전 13 밑으로는 `ComponentFactory`를, 버전 13 부터는 생성할 컴포넌트 클래스를 인자로 전달하면
해당 `ViewContainerRef`에 컴포넌트를 동적으로 추가할 수 있게 된다.

```typescript
@Component({
  selector: 'app-view',
  template: ``,
})
export class ViewComponent implements AfterViewInit {
  constructor(
    private viewContainerRef: ViewContainerRef,
    private componentFactoryResolver: ComponentFactoryResolver,
  ) {
  }

  ngAfterViewInit(): void {
    // Under Angular 13
    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(SomeComponent);
    
    this.viewContainerRef.createComponent(componentFactory);
    
    // From Angular 13
    this.viewContainerRef.createComponent(SomeComponent);
  }
}
```

여기 까지는 아무 문제가 없는데, `Injector`를 사용할 때 특정 상황에서 에러가 발생했다.

# Dependency injection for dynamic component

`Injector`를 이용해 특정 클래스나 값을 동적 컴포넌트에 주입하고자 할 때
아래와 같은 방법을 사용할 수 있다.

```typescript
@Component({
  selector: 'app-view',
  template: ``,
})
export class ViewComponent implements AfterViewInit {
  constructor(
    private viewContainerRef: ViewContainerRef,
    private componentFactoryResolver: ComponentFactoryResolver,
  ) {
  }

  ngAfterViewInit(): void {
    const injector = Injector.create({
      providers: [
        {
          provide: 'SomeThing',
          useValue: 'SomeValue',
        },
      ],
    });
    
    // Under Angular 13
    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(SomeComponent);
    
    this.viewContainerRef.createComponent(componentFactory, null, injector);
    
    // From Angular 13
    this.viewContainerRef.createComponent(SomeComponent, { injector });
  }
}
```

일반적으로 여기 까지는 아무 문제가 없다.

하지만 앞서 말했듯 **특정 상황**에서 에러가 발생하는데, 만약 여기서 `SomeComponent` 내에 아래와 같이
`Renderer2`를 주입하려고 하면 이 포스팅의 제목과 동일한 에러를 볼 수 있다.

```typescript
@Component({
  selector: 'app-some',
  template: ``,
})
export class SomeComponent implements AfterViewInit {
  constructor(
    // It causes 'Cannot inject Renderer2 when the application uses Renderer3!'
    private renderer: Renderer2,
  ) {
  }
}
```

말 그대로 어플리케이션이 Renderer3를 사용중일 경우 Renderer2를 주입할 수 없다는 것이다.

# What is the problem?

그럼 문제가 무엇이냐?

바로 `Injector.create()` 메서드 때문이다.

Angular 13.2.0에 들어서면서 `Injector`는 컴포넌트가 `RendererFactory2`에 바인딩 될 필요가 없을 경우
기본적으로 `Renderer3`를 사용한다. 즉, `Injector.create()` 메서드는 `Renderer3`으로 만들어지는 것이다.
그런데 `SomeComponent`에선 `Renderer2`를 주입하려 하니 문자 그대로의
**'Cannot inject Renderer2 when the application uses Renderer3!'**라는 에러가 나타나게 된다.

이게 내가 만든 컴포넌트에서만 문제가 발생하면 그나마 다행인데,
`FormsModule`을 사용할 때도 에러가 발생했다. 아마 내부에서 `Renderer2`를 주입하는 부분이 있는 듯?

그래서 이 부분은 버그로 규정이 되었고 자세한 내용은
내가 Angular 공식 Github에 남긴 [이슈](https://github.com/angular/angular/issues/44897)를 확인하자.

# So, what's the solution?

하지만 버그 픽스가 완료될 때 까지 기다릴 만큼 한국인은 호락호락한 민족이 아니다.

그걸 알았는지 위 이슈에서 [@alxhub](https://github.com/alxhub)라는 Angular 개발자가 답변을 달아줬는데,
해결책은 간단했다. `Injector`가 `Renderer2`를 사용하도록 하면 되는 것이다.

이 부분은 가정인데, 아마 아직까지 컴포넌트는 기본적으로 생성될 때 `Renderer2`를 사용하는 모양이다.
그래서 기존에 컴포넌트 내에서 `Renderer2`를 주입하는 부분에서는 에러가 발생하지 않는다.
따라서 여기서 해줄 일은 이미 생성된 컴포넌트의 `Injector`를 새로 생성하는 `Injector`에 상속해주는 것이다.

다행히 `Injector.create()` 메서드는 옵션에 `parent`라는 필드를 이용해
상속할 부모 `Injector`를 전달할 수 있다.

```typescript
@Component({
  selector: 'app-view',
  template: ``,
})
export class ViewComponent implements AfterViewInit {
  constructor(
    private injector: Injector,
    private viewContainerRef: ViewContainerRef,
    private componentFactoryResolver: ComponentFactoryResolver,
  ) {
  }

  ngAfterViewInit(): void {
    const injector = Injector.create({
      providers: [
        {
          provide: 'SomeThing',
          useValue: 'SomeValue',
        },
      ],
      // Inherit parent injector which is created with Renderer2
      // to prevent using Renderer3.
      parent: this.injector,
    });
    
    this.viewContainerRef.createComponent(SomeComponent, { injector });
  }
}
```

이렇게 하면 에러가 깔끔하게 해결된다.

# 마무리

Angular Github에서 버그라고 했으니 아마 수정될 것 같긴 하지만
같은 이슈로 지금 문제를 겪는 사람들이 있을까봐 포스팅을 해보았다.

그리고 이런 정보는 알아두면 Angular 동작 원리에 대한 이해도를 높일 수 있기 때문에
나쁘지 않은 듯 !
